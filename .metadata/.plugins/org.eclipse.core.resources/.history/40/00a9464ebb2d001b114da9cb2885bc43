#include <cstdio>

///#define nv 10
///#define nc 3

void main()
{
	float v_datos_default [nv] = {1,3,2,5,7,11,4,2,1,3};
	float v_coef_default [nc] = {0.33,0.33,0.33};

	float salida,valorEntrada;

	int indiceValor,indiceCoeficiente,tmp,nv,nc;
	char borrador;

	float * restrict v_coef; ///puntero hacia array con los coeficientes leidos desde fichero csv
	float * restrict v_datos; ///puntero hacia array con los datos leidos desde fichero csv
	///
	///Primero intento abrir fichero de coeficientes
	///
	FILE *fich_num = fopen("Coeficientes.csv",r);

	if (fich_num == NULL){
		///
		///si no se encontró o pudo abrir, lo indico y utilizao el array por defecto.
		///
		printf("No se puede abrir fichero\n");
		printf("Usando valores por defecto");

		nc=3;
		v_coef = &v_coef_default;
	}

	else
	{

		nc=0;
		while (!feof(fich_num))
		{
			fscanf(fich_num,"%f",&v_fich_num_csv[tmp]); ///leo el valor en flotante
			nc++; ///numero de coeficientes que he leido
			if (!feof(fich_num))
				fscanf(fich_num,"%c",&borrador); ///leo la coma.

		}
		v_coef =  malloc(nc * sizeof(float));
		fseek(fich_num,0,SEEK_SET); ///me vuelvo a colocar al principio del fichero

		while (!feof(fich_num))
		{
			fscanf(fich_num,"%f",&v_fich_num_csv[tmp]); ///leo el valor en flotante
			nc++; ///numero de coeficientes que he leido
			if (!feof(fich_num))
				fscanf(fich_num,"%c",&borrador); ///leo la coma.

		}

	}

  fclose(fich_num);

//	   for ( j = 0; j < nv; j++)
	//    	printf("%lf\n",v_datos[j]);
	    for ( j = 0; j < nc; j++)
	    	printf("%lf\n",v_coef[j]);*/

///Una vez rellenados los vectores de coeficientes y de datos, procedo al cáculo de la salida

	///bucle que comprobará todas las entradas posibles.
  for (indiceValor = 0; indiceValor < nv+nc; indiceValor++)
  {
		salida=0.0; ///inicialmente salida = 0

	  //bucle que realiza el cáculo para una entrada dada
	    for (indiceCoeficiente=0; indiceCoeficiente < nc;indiceCoeficiente++) ///tengo que sumar si o sí, mientras no recorra todos los coeficientes.
	    {
	      tmp=indiceValor-indiceCoeficiente;
	    	if ((tmp >= 0) && (tmp < nv))
	    		valorEntrada= v_datos[tmp];
	    	else
	    		valorEntrada = 0.0;

	    	salida = salida + (v_coef[indiceCoeficiente]*valorEntrada);

	    }

	    printf("\nIteración : %d Valor: %lf",indiceValor,salida);
  }

}

/*
	// ========================
	//  AQUI USAMOS ALIASING y RESIRTIC
	// ========================
	int data1 = 20;
	int data2 = 30;
//  Sin Aliasing
	int resultado = sumAlising(&data1, &data1);
//  Con Restrict
//	int resultado = sumRestrict(&data1, &data2);
	printf("resultado %d\n",resultado);
*/

	// ========================
	//  AQUI USAMOS INTRÍNSECOS. _SADD
	// ========================

	/*
    int intrinseco[nv], manual[nv];

	int valor1 = 10, valor2 = 4;

    printf("Sadd intrínseco\n");
    // int _sadd(int src1, int src2);
    // Adds src1 to src2 and saturates the result.
    // Returns the result
	for(i=1;i<nv;i++){
		intrinseco[i] = _sadd(valor1,valor2);
		printf("añadir--> %d\n", intrinseco[i]);
	}

    printf("Sadd sin intrínseco");
	for(i=1;i<nv;i++){
		manual[i] = sadd(valor1,valor2);
		printf("añadir. Add programado--> %d\n", manual[i]);
	}
	*/

	// ========================
	//  AQUI USAMOS INTRÍNSECOS. Multiplicación
	// ========================
	/*
	short in1[nv], in2[nv];
	short *pin1 = &in1[0];
	short *pin2 = &in2[0];
	int N = 100;
	int resultado,i;

	for(i=0;i<N;i++){
		in1[i] = i*10;
		in2[i] = i+10;
	}

	resultado = dotproducto(pin1, pin2, N);
	printf("%d",resultado);
	*/

	// ========================
	//  AQUI USAMOS PRAGMAS
	// ========================
	// ========================
	//  Optimizar bucles haciendo
	//  cuenta descendente
	// ========================
	/*
	int i;
	int N = 200;
	printf("Cuenta creciente\n");
	for (i = 0; i < N; i++){ // i = trip counter, N = trip count
		printf("%d\n",i);
	}
	printf("Cuenta decreciente\n");
	for (i = N; i != 0; i--){ // Downcounting trip counter
		printf("%d\n",i);
	}
	printf("Fin\n");


	// ========================
	//  AQUI USAMOS MUST ITERATE
	// ========================

	short sum[nv], in1[nv], in2[nv];
	short *psum = &sum[0];
	short *pin1 = &in1[0];
	short *pin2 = &in2[0];

	int N = 50;
	int i;

	for(i=0;i<N;i++){
		in1[i] = i*10;
		in2[i] = i+10;
	}
	printf("\nSin must iterator\n");
	vecsumSinMust(psum, pin1, pin2, N);

	for(i=0;i<N;i++){
		in1[i] = i*10;
		in2[i] = i+10;
	}

	printf("\Con must iterator\n");
	vecsumConMust(psum, pin1, pin2, N);


	// ========================
	//  AQUI USAMOS _nassert
	// ========================
	/*
	short in1[nv], in2[nv], sum[nv];
	short *pin1 = &in1[0];
	short *pin2 = &in2[0];
	int N = 100;
	int resultado,i;

	for(i=0;i<N;i++){
		in1[i] = i*10;
		in2[i] = i+10;
	}

	resultado = dotproductonassert(pin1, pin2, N);
	printf("%d",resultado);
	*/

	// ========================
	//  AQUI USAMOS Desenrrollar bucles
	// ========================

	/*
	int sum[nv], in1[nv], in2[nv];
	int *psum = &sum[0];
	int *pin1 = &in1[0];
	int *pin2 = &in2[0];
	int N = 10;
	int i;

	for(i=0;i<N;i++){
		in1[i] = i*10;
		in2[i] = i+10;
	}

	vecsumSinDesenrrollar(psum, pin1, pin2, N);
	vecsumDesenrrollado(psum, pin1, pin2, N);
	*/
